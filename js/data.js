const quizData = [
    {
        // V字モデル（受入テスト）
        question: "ECサイト構築プロジェクトの最終段階で、顧客が「注文から決済まで要望通りに完了できるか」を確認し、納品を承認するためのテストは？",
        options: [
            { text: "単体テスト", isCorrect: false, rationale: "決済モジュールなどの個々の部品が正しく動くかを確認する工程です。" },
            { text: "結合テスト", isCorrect: false, rationale: "注文画面と決済システムが連携できるかを確認する工程です。" },
            { text: "システムテスト", isCorrect: false, rationale: "開発側が、システム全体の機能や性能が仕様通りかを確認する工程です。" },
            { text: "受入テスト", isCorrect: true, rationale: "発注者（顧客）が、実際の業務で使えるか最終確認を行うテスト工程です。" }
        ]
    },
    {
        // ホワイトボックステスト
        question: "Webアプリのログイン機能で、ソースコード内の「パスワードが空の場合」「形式が不正な場合」といった条件分岐が全て網羅されているかを確認するテスト手法は？",
        options: [
            { text: "ホワイトボックステスト", isCorrect: true, rationale: "内部のロジックやコード構造を意識し、すべての経路を検証する手法です。" },
            { text: "ブラックボックステスト", isCorrect: false, rationale: "画面操作で、入力に対して正しいエラーメッセージが出るかのみを確認する手法です。" },
            { text: "静的テスト", isCorrect: false, rationale: "コードを実行せず、レビューなどで不具合を探す手法です。" },
            { text: "ユーザビリティテスト", isCorrect: false, rationale: "ログイン画面の使いやすさや分かりやすさを確認するテストです。" }
        ]
    },
    {
        // 回帰テスト
        question: "Playwright や Seleniumを使って、ショッピングカートに「クーポン機能」を追加した後、既存の「購入手続きフロー」が壊れていないか自動で確認するテストは？",
        options: [
            { text: "スモークテスト", isCorrect: false, rationale: "アプリが起動するかなど、最低限の動作を確認するテストです。" },
            { text: "回帰（リグレッション）テスト", isCorrect: true, rationale: "修正によって既存の正常な機能に悪影響（デグレード）が出ていないかを確認する再テストです。" },
            { text: "パフォーマンステスト", isCorrect: false, rationale: "カートへの商品追加時の応答速度などを測定するテストです。" },
            { text: "セキュリティテスト", isCorrect: false, rationale: "クーポンコードの不正利用ができないかなどを確認するテストです。" }
        ]
    },
    {
        // 境界値分析
        question: "RPGゲームで、キャラクターのHPが「1残って生存する場合」と「0になって戦闘不能になる場合」の境目を重点的に確認する効率的なテスト技法は？",
        options: [
            { text: "同値分割", isCorrect: false, rationale: "「HPが満タン」「HPが半分」のようなグループから代表値を選ぶ手法です。" },
            { text: "境界値分析", isCorrect: true, rationale: "不具合が発生しやすい「値の境目（境界値）」を狙い撃ちする技法です。" },
            { text: "原因結果グラフ", isCorrect: false, rationale: "複雑な条件の組み合わせを論理的に整理する手法です。" },
            { text: "モンキーテスト", isCorrect: false, rationale: "ランダムに操作して予期せぬバグを探す手法です。" }
        ]
    },
    {
        // 負荷テスト
        question: "チケット予約サイトで、販売開始時刻に数万人のアクセスが殺到してもサーバーがダウンせず応答できるかを、k6などを使って確認するテストは？",
        options: [
            { text: "可用性テスト", isCorrect: false, rationale: "システムが長時間安定して稼働し続けられるかを確認するテストです。" },
            { text: "負荷（ストレス）テスト", isCorrect: true, rationale: "限界に近い負荷をかけ、システムの耐久性やダウン時の挙動を確認するテストです。" },
            { text: "互換性テスト", isCorrect: false, rationale: "PCやスマホなど、異なる環境での表示崩れがないかを確認するテストです。" },
            { text: "APIテスト", isCorrect: false, rationale: "サーバー内部のデータ連携が正しく行われるかを確認するテストです。" }
        ]
    },
    {
        // アジャイル型
        question: "2週間の短いサイクル（スプリント）を繰り返し、プレイヤーからのフィードバックをもとに新イベント機能などを追加し続ける、ソーシャルゲーム開発に適したモデルは？",
        options: [
            { text: "ウォーターフォール型", isCorrect: false, rationale: "最初に全ての仕様を決め、リリースまで変更を行わないモデルです。" },
            { text: "アジャイル型", isCorrect: true, rationale: "変化に柔軟に対応し、短期間で開発とリリースを繰り返す手法です。" },
            { text: "プロトタイプ型", isCorrect: false, rationale: "試作品を作って操作感を確かめてから本開発に入る手法です。" },
            { text: "V字モデル型", isCorrect: false, rationale: "開発工程とテスト工程の対応関係を示すモデルで、開発手法そのものではありません。" }
        ]
    },
    {
        // TDD
        question: "Webアプリの複雑な計算ロジックを実装する際、「まず失敗するテストを書き、それをパスする実装を行い、最後にコードを整理する」という手順で進める開発手法は？",
        options: [
            { text: "実装優先開発", isCorrect: false, rationale: "まず動くコードを書き、後からテストを追加する一般的な手法です。" },
            { text: "設計駆動開発", isCorrect: false, rationale: "詳細な設計書を完備してから実装に入る手法です。" },
            { text: "TDD（テスト駆動開発）", isCorrect: true, rationale: "「Red(失敗)→Green(成功)→Refactor(整理)」のサイクルを回し、品質の高いコードを保つ手法です。" },
            { text: "AI駆動型開発", isCorrect: false, rationale: "AIにコード生成を支援させる手法で、TDDのサイクルとは異なります。" }
        ]
    },
    {
        // AI駆動型
        question: "ゲーム開発でGitHub Copilotを使い、課金アイテムの付与ロジックをAIに自動生成させた。このコードを利用する際に最も重要な注意点は？",
        options: [
            { text: "AIのコードは完璧なのでそのまま使う", isCorrect: false, rationale: "AIもバグを含んだり、誤ったロジックを生成したりする可能性があります（ハルシネーション）。" },
            { text: "テストコードは不要になる", isCorrect: false, rationale: "AIが生成したコードこそ、人間による厳密なテストが不可欠です。" },
            { text: "人間がレビューし、テストを行う", isCorrect: true, rationale: "ハルシネーションやセキュリティリスクを考慮し、最終的な品質責任は人間が持つ必要があります。" },
            { text: "個人開発以外では使ってはいけない", isCorrect: false, rationale: "適切なレビュー体制があれば、チーム開発でも有効に活用できます。" }
        ]
    },
    {
        // ハイブリッド型
        question: "大規模な企業の基幹システム刷新プロジェクトで、全体の予算や納期はウォーターフォールで堅実に管理しつつ、各機能の実装はアジャイルで柔軟に進める手法は？",
        options: [
            { text: "フルアジャイル型", isCorrect: false, rationale: "全体の計画も柔軟に変更していくため、予算管理が難しくなる場合があります。" },
            { text: "ハイブリッド型", isCorrect: true, rationale: "伝統的な管理手法（安定性）とモダンな開発手法（柔軟性）の利点を組み合わせた現実的な手法です。" },
            { text: "フルウォーターフォール型", isCorrect: false, rationale: "開発途中の仕様変更に対応するのが非常に困難な手法です。" },
            { text: "スパイラル型", isCorrect: false, rationale: "リスク分析を重視し、プロトタイプ作成を繰り返す手法です。" }
        ]
    },
    {
        // カバレッジ
        question: "JavaScriptのテストフレームワーク「Jest」を使い、作成した単体テストが、ソースコード内のすべてのif文の分岐を何％通過したかを示す指標は？",
        options: [
            { text: "レスポンスタイム", isCorrect: false, rationale: "処理にかかる時間のことです。" },
            { text: "スループット", isCorrect: false, rationale: "単位時間あたりの処理件数のことです。" },
            { text: "コードカバレッジ（網羅率）", isCorrect: true, rationale: "ホワイトボックステストにおいて、テストがどれだけコードを網羅できたかを測る重要な指標です。" },
            { text: "バグ検出率", isCorrect: false, rationale: "埋め込まれたバグのうち、何割を見つけられたかを示す指標です。" }
        ]
    },
    // --- 追加したCI/CDの問題 ---
    {
        // CI（継続的インテグレーション） - Webアプリ観点
        question: "Webアプリ開発チームで、各開発者がコードをGitHubにプッシュするたびに、自動的にビルドとJestによる単体テストが実行される仕組みを導入した。この取り組みは何と呼ばれるか？",
        options: [
            { text: "CD（継続的デリバリー）", isCorrect: false, rationale: "CDは、テストを通過したコードを自動的にデプロイ（適用）可能な状態にする工程を指します。" },
            { text: "CI（継続的インテグレーション）", isCorrect: true, rationale: "コードの変更を頻繁に統合し、自動テストによって問題を早期に発見する仕組みです。" },
            { text: "バージョン管理", isCorrect: false, rationale: "Gitなどを用いてコードの変更履歴を管理することですが、自動テストの実行までは含みません。" },
            { text: "IaC（Infrastructure as Code）", isCorrect: false, rationale: "サーバーなどのインフラの設定をコード化して管理する手法です。" }
        ]
    },
    {
        // CD（継続的デプロイメント） - Webアプリ観点
        question: "Webサービスの新機能をリリースする際、CIパイプラインでの全テスト成功をトリガーとして、人の手を介さずに自動で本番環境へ新バージョンを反映させる仕組みは？",
        options: [
            { text: "継続的デプロイメント（CD）", isCorrect: true, rationale: "テストをパスしたソフトウェアを、自動的に本番環境へリリースする仕組みです。" },
            { text: "継続的インテグレーション（CI）", isCorrect: false, rationale: "ビルドとテストを自動化する段階までを指します。" },
            { text: "ブルーグリーンデプロイメント", isCorrect: false, rationale: "安全なデプロイ戦略の一つですが、自動化の仕組みそのものを指す言葉ではありません。" },
            { text: "ステージング環境", isCorrect: false, rationale: "本番環境へのデプロイ前に最終確認を行うためのテスト環境のことです。" }
        ]
    },
    {
        // CI/CD全体 - ゲーム開発観点
        question: "スマートフォン向けゲーム開発で、プログラムだけでなく3Dモデルや画像などの巨大なアセットが変更された際にも、自動でビルドと実機での起動テストを行うCI/CDパイプラインを構築した。これによる主なメリットは？",
        options: [
            { text: "ゲームのフレームレートが向上する", isCorrect: false, rationale: "CI/CDは開発プロセスの効率化であり、ゲーム自体の性能を直接向上させるものではありません。" },
            { text: "アセットのファイルサイズが自動的に圧縮される", isCorrect: false, rationale: "ビルドプロセスに含まれる可能性はありますが、CI/CD導入の主目的ではありません。" },
            { text: "開発者のローカルPCのストレージ容量が節約できる", isCorrect: false, rationale: "ローカルでの作業内容は変わらないため、ストレージの節約には直結しません。" },
            { text: "アセットとコードの不整合によるビルドエラーを早期に発見し、常にプレイ可能な状態を保てる", isCorrect: true, rationale: "ゲーム開発特有の「コードと素材の組み合わせ」による問題を早期に検知できる点が大きなメリットです。" }
        ]
    },
    {
        // 14問目：テストレベルと実施主体の整理
        question: "Webアプリ開発における『システムテスト』と『受入テスト』の説明として、最も適切なものはどれか？",
        options: [
            { text: "システムテストはユーザーが実施し、業務に使えるかを判断する。", isCorrect: false, rationale: "それは『受入テスト』の説明です。システムテストは主に開発側が実施します。" },
            { text: "システムテストは開発側が実施し、システム全体が仕様通りに動くかを確認する。", isCorrect: true, rationale: "システムテストは、開発チームが設計書（仕様書）に基づいて全体機能を検証する工程です。" },
            { text: "受入テストはソースコードの分岐網羅率（カバレッジ）を100%にするのが目的である。", isCorrect: false, rationale: "カバレッジを重視するのは主に『単体テスト』の段階です。受入テストは業務適合性を重視します。" },
            { text: "受入テストに合格すれば、システムテストは省略して良い。", isCorrect: false, rationale: "受入テストはあくまで最終確認であり、その前に開発側でのシステムテストによる品質保証が必須です。" }
        ]
    },
    {
        // 15問目：テスト技法とテストレベルの総合知識
        question: "ゲーム開発におけるテスト手法の組み合わせとして、正しい記述はどれか？",
        options: [
            { text: "単体テストでは、主にブラックボックステストを用いて画面の見た目を確認する。", isCorrect: false, rationale: "単体テストはロジックを確認するため、主に内部構造を意識した『ホワイトボックス』が用いられます。" },
            { text: "同値分割は、バグが出やすい「数値の境目」だけを狙ってテストする技法である。", isCorrect: false, rationale: "それは『境界値分析』の説明です。同値分割はグループから代表値を選ぶ技法です。" },
            { text: "結合テストでは、複数のモジュールを繋ぎ、データの受け渡しが正しいかを確認する。", isCorrect: true, rationale: "部品（モジュール）を組み合わせた際のインターフェースや連携を確認するのが結合テストの役割です。" },
            { text: "ホワイトボックステストは、プログラムの中身（コード）を見ずに仕様だけでテストする。", isCorrect: false, rationale: "それは『ブラックボックステスト』の説明です。ホワイトは中身（ロジック）を意識します。" }
        ]
    }
];